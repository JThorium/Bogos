import { gameFrame, ghostTimer, spectreTimer, setGhostTimer, setMaterialsThisRun, setWaveCredits, scoreMultiplier, currentBoss, player, enemies, enemyBullets, particles, powerups, obstacles, turrets } from './gameData.js';
import { projectAndDrawWireframe } from './utils.js';
import { ASTEROID_MODEL } from './models.js';
import { createExplosion, addScore, isColliding, triggerScreenShake, showInGameShop, startMusic } from './game.js';
import { sfx } from './audio.js';

export class Bullet { constructor(x, y, speedX, speedY, color, damage = 1) { this.x = x; this.y = y; this.speedX = speedX; this.speedY = speedY; this.size = 5; this.color = color; this.damage = damage; this.canSlow = false; } update() { let timeMod = 1; if (player.abilityState.name === 'chronomancer' && player.abilityState.active && Math.hypot(this.x-player.x, this.y-player.y) < 200) { timeMod = 0.2; } this.x += this.speedX * timeMod; this.y += this.speedY * timeMod; if (gameFrame % 3 === 0) particles.push(new Particle(this.x, this.y, 0, this.speedY * 0.2, this.color, 2, 8)); } draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } }
export class HomingBullet extends Bullet { constructor(x, y, speedX, speedY, color, damage, range = 400) { super(x, y, speedX, speedY, color, damage); this.turnSpeed = 0.05; this.target = null; this.range = range; } update() { if (!this.target || enemies.indexOf(this.target) === -1) this.findTarget(); if(this.target) { const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x); const currentAngle = Math.atan2(this.speedY, this.speedX); let angleDiff = targetAngle - currentAngle; while (angleDiff > Math.PI) angleDiff -= 2*Math.PI; while (angleDiff < -Math.PI) angleDiff += 2*Math.PI; const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(this.turnSpeed, Math.abs(angleDiff)); const speed = Math.hypot(this.speedX, this.speedY) + 0.1; this.speedX = Math.cos(newAngle) * speed; this.speedY = Math.sin(newAngle) * speed;} super.update(); } findTarget() { let closestDist = Infinity; this.target = null; for(const enemy of enemies) { const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y); if (dist < closestDist && dist < this.range) { closestDist = dist; this.target = enemy; } } } }
export class Star { constructor() { this.x = Math.random() * screenWidth; this.y = Math.random() * screenHeight; this.size = Math.random() * 2 + 1; this.speed = this.size * 0.5; } update() { let timeMod = 1; if (player && player.abilityState.name === 'chronomancer' && player.abilityState.active && Math.hypot(this.x-player.x, this.y-player.y) < 200) { timeMod = 0.2; } this.y += this.speed * timeMod; if (this.y > screenHeight) { this.y = -this.size; this.x = Math.random() * screenWidth; } } draw() { ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 3})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } }
export class Particle { constructor(x, y, speedX, speedY, color, size, lifespan) { this.x = x; this.y = y; this.speedX = speedX + (Math.random() - 0.5) * 2; this.speedY = speedY + (Math.random() - 0.5) * 2; this.color = color; this.size = size; this.lifespan = lifespan; this.maxLifespan = lifespan; } update() { this.x += this.speedX; this.y += this.speedY; this.lifespan--; this.size *= 0.95; } draw() { const rgb = `${parseInt(this.color.slice(1, 3), 16)}, ${parseInt(this.color.slice(3, 5), 16)}, ${parseInt(this.color.slice(5, 7), 16)}`; ctx.fillStyle = `rgba(${rgb}, ${this.lifespan / this.maxLifespan})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } }
export class PowerUp { constructor(x, y) { this.x = x; this.y = y; this.size = 10; this.speedY = 2; const types = ['shield', 'minion', 'ghost', 'bomb']; this.type = types[Math.floor(Math.random() * types.length)]; this.color = { shield: '#60a5fa', minion: '#a78bfa', ghost: '#e5e7eb', bomb: '#ffffff'}[this.type]; } update() { this.y += this.speedY; } draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2); ctx.fillStyle = "black"; ctx.font = "12px 'Press Start 2P'"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const label = { shield: 'S', minion: 'M', ghost: 'G', bomb: 'B'}[this.type]; ctx.fillText(label, this.x, this.y); } }
export class RawMaterialPickup extends PowerUp { constructor(x, y) { super(x, y); this.type = 'material'; this.color = '#94a3b8'; } draw() { ctx.fillStyle = this.color; ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(Math.PI / 4); ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2); ctx.restore(); ctx.fillStyle = "black"; ctx.font = "12px 'Press Start 2P'"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('[M]', this.x, this.y); } }
export class Obstacle { constructor(type) { this.type = type; this.x = Math.random() * screenWidth; this.y = -50; this.speedY = Math.random() * 1 + 0.5; this.size = Math.random() * 20 + 15; this.angleX = Math.random()*Math.PI*2; this.angleY = Math.random()*Math.PI*2; this.angleZ = 0; this.rotationSpeed = (Math.random() - 0.5) * 0.02; if(type === 'asteroid') { this.health = this.size / 10; this.color = '#a1a1aa'; this.model = ASTEROID_MODEL; } else if (type === 'blackhole') { this.color = '#000'; this.size = Math.random() * 30 + 40; this.gravityWell = this.size * 4; this.lifespan = 600; this.y = Math.random() * screenHeight * 0.6; sfx.blackhole.triggerAttack(); } } update() { this.angleY += this.rotationSpeed; if(this.type === 'asteroid') { this.y += this.speedY; } else if(this.type === 'blackhole') { if(player) { const dx = this.x-player.x; const dy = this.y-player.y; const dist = Math.hypot(dx,dy); if(dist < this.gravityWell) { const pull = (1 - dist / this.gravityWell) * 0.2; player.x += dx/dist * pull; player.y += dy/dist * pull; if(dist < this.size) player.hit(); }} this.lifespan--; if(this.lifespan <= 0) sfx.blackhole.triggerRelease(); }} draw() { if(this.type === 'asteroid') { projectAndDrawWireframe(this.model, this.x, this.y, this.size, {x:this.angleX, y:this.angleY, z:this.angleZ}, this.color, 1.5); } else if(this.type === 'blackhole') { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = `rgba(200, 50, 255, ${0.5 + Math.sin(gameFrame*0.1)*0.2})`; ctx.lineWidth = 3; ctx.stroke(); } } takeDamage(amount) { if(this.type !== 'asteroid') return false; this.health -= amount; return this.health <= 0; } }
