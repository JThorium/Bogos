<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Astro Annihilator - Beta 1</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      color: #0f0;
      text-align: center;
    }
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #canvas {
      border: 1px solid #333;
      display: block;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: lime;
      font-size: 16px;
      text-shadow: 0 0 5px black;
      z-index: 10;
    }
    #pause-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      padding: 20px;
      border: 2px solid lime;
      color: lime;
      font-size: 24px;
      z-index: 100;
      display: none;
    }
    button {
      background: #000;
      color: lime;
      border: 1px solid lime;
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
      font-family: 'Courier New';
    }
    button:hover {
      background: #030;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="canvas"></canvas>
    <div id="ui">
      Health: <span id="health">100</span> | 
      Score: <span id="score">0</span> | 
      Level: <span id="level">1</span> | 
      Ammo: <span id="ammo">∞</span> | 
      <span id="power-ups"></span>
    </div>
    <div id="pause-menu">
      <div>PAUSED</div>
      <button id="resume-btn">Resume</button>
      <button id="restart-btn">Restart</button>
    </div>
  </div>

  <script>
    // === MODULAR GAME ENGINE ===
    const Game = {
      canvas: null,
      ctx: null,
      width: window.innerWidth,
      height: window.innerHeight,
      running: false,
      paused: false,
      keys: {},
      lastTime: 0,
      highScore: localStorage.getItem('AA_HighScore') || 0,
      init() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => this.keys[e.key] = true);
        window.addEventListener('keyup', e => this.keys[e.key] = false);
        document.getElementById('resume-btn').onclick = () => this.togglePause();
        document.getElementById('restart-btn').onclick = () => this.restart();

        // Start game loop
        this.running = true;
        this.lastTime = performance.now();
        this.run(this.lastTime);
      },
      resize() {
        this.canvas.width = this.width = window.innerWidth;
        this.canvas.height = this.height = window.innerHeight;
      },
      run(currentTime) {
        if (!this.running) return;
        const dt = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;

        if (!this.paused) {
          this.update(dt);
        }
        this.render();

        requestAnimationFrame(this.run.bind(this));
      },
      togglePause() {
        this.paused = !this.paused;
        document.getElementById('pause-menu').style.display = this.paused ? 'block' : 'none';
      },
      restart() {
        this.paused = false;
        document.getElementById('pause-menu').style.display = 'none';
        GameState.reset();
      }
    };

    // === GAME STATE ===
    const GameState = {
      score: 0,
      level: 1,
      enemies: [],
      bullets: [],
      particles: [],
      powerUps: [],
      player: null,
      boss: null,
      spawnRate: 2.0,
      nextSpawn: 0,
      nextBoss: 5,
      highScore: parseInt(Game.highScore),
      updateScore(points) {
        this.score += points;
        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('AA_HighScore', this.highScore);
        }
        document.getElementById('score').textContent = this.score;
      },
      levelUp() {
        this.level++;
        this.spawnRate = Math.max(0.5, 2.0 - this.level * 0.1);
        this.enemies = [];
        this.bullets = [];
        PowerUp.spawnRandom(Game.width / 2, Game.height / 2); // reward
        if (this.level % 5 === 0) {
          this.spawnBoss();
        }
      },
      spawnBoss() {
        this.boss = new Boss(Game.width / 2, -100);
      },
      reset() {
        this.score = 0;
        this.level = 1;
        this.spawnRate = 2.0;
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.powerUps = [];
        this.boss = null;
        Game.keys = {};
        GameState.player = new Player(Game.width / 2, Game.height - 100);
        document.getElementById('score').textContent = '0';
        document.getElementById('level').textContent = '1';
        document.getElementById('health').textContent = '100';
        document.getElementById('power-ups').textContent = '';
      }
    };

    // === ENTITIES ===
    class Entity {
      constructor(x, y, w, h, color) {
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h;
        this.color = color;
        this.velX = 0;
        this.velY = 0;
        this.active = true;
      }
      update(dt) {
        this.x += this.velX;
        this.y += this.velY;
      }
      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
      }
      isColliding(other) {
        return (
          this.x - this.width / 2 < other.x + other.width / 2 &&
          this.x + this.width / 2 > other.x - other.width / 2 &&
          this.y - this.height / 2 < other.y + other.height / 2 &&
          this.y + this.height / 2 > other.y - other.height / 2
        );
      }
    }

    // === PLAYER ===
    class Player extends Entity {
      constructor(x, y) {
        super(x, y, 40, 40, '#0f0');
        this.health = 100;
        this.fireRate = 0.2;
        this.lastFire = 0;
        this.rapidFire = false;
        this.rapidFireTime = 0;
        this.laserBeam = false;
        this.laserTime = 0;
        this.invincible = false;
        this.invincibleTime = 0;
      }

      update(dt) {
        // Movement
        const speed = 300;
        if (Game.keys['ArrowLeft'] || Game.keys['a']) this.x = Math.max(20, this.x - speed * dt);
        if (Game.keys['ArrowRight'] || Game.keys['d']) this.x = Math.min(Game.width - 20, this.x + speed * dt);
        if (Game.keys['ArrowUp'] || Game.keys['w']) this.y = Math.max(20, this.y - speed * dt);
        if (Game.keys['ArrowDown'] || Game.keys['s']) this.y = Math.min(Game.height - 20, this.y + speed * dt);

        // Fire
        this.lastFire -= dt;
        if ((Game.keys[' '] || Game.keys['f']) && this.lastFire <= 0) {
          this.fire();
          this.lastFire = this.rapidFire ? 0.05 : this.fireRate;
        }

        // Update power-up timers
        if (this.rapidFireTime > 0) {
          this.rapidFireTime -= dt;
          if (this.rapidFireTime <= 0) this.rapidFire = false;
        }
        if (this.laserTime > 0) {
          this.laserTime -= dt;
          if (this.laserTime <= 0) this.laserBeam = false;
        }
        if (this.invincibleTime > 0) {
          this.invincibleTime -= dt;
          if (this.invincibleTime <= 0) this.invincible = false;
        }

        // Update UI
        document.getElementById('health').textContent = Math.ceil(this.health);
        document.getElementById('ammo').textContent = this.laserBeam ? 'LASER' : '∞';
        const puText = [];
        if (this.rapidFire) puText.push('RAPID');
        if (this.laserBeam) puText.push('LASER');
        if (this.invincible) puText.push('SHIELD');
        document.getElementById('power-ups').textContent = puText.join(', ');

        // Pause toggle
        if (Game.keys['Escape'] || Game.keys['p']) {
          setTimeout(() => Game.togglePause(), 100); // debounce
        }
      }

      fire() {
        if (this.laserBeam) {
          GameState.bullets.push(new Bullet(this.x, this.y - 20, 0, -800, '#0ff', 5, 60));
          GameState.bullets.push(new Bullet(this.x - 15, this.y - 10, 0, -600, '#0ff', 3, 40));
          GameState.bullets.push(new Bullet(this.x + 15, this.y - 10, 0, -600, '#0ff', 3, 40));
        } else {
          GameState.bullets.push(new Bullet(this.x, this.y - 20, 0, -600));
          for (let i = 0; i < 3; i++) {
            Particle.spawn(this.x, this.y - 10, '#0f0');
          }
        }
      }

      takeDamage(amount) {
        if (this.invincible) return;
        this.health -= amount;
        this.invincible = true;
        this.invincibleTime = 2.0;
        if (this.health <= 0) {
          this.die();
        }
      }

      die() {
        this.active = false;
        for (let i = 0; i < 20; i++) {
          Particle.spawn(this.x, this.y, '#f00');
        }
        Game.running = false;
        setTimeout(() => {
          alert(`Game Over! Score: ${GameState.score} | High Score: ${GameState.highScore}`);
          Game.restart();
        }, 500);
      }
    }

    // === BULLET ===
    class Bullet extends Entity {
      constructor(x, y, vx, vy, color = '#ff0', w = 3, h = 10) {
        super(x, y, w, h, color);
        this.velX = vx;
        this.velY = vy;
      }
      update(dt) {
        this.y += this.velY * dt;
        this.x += this.velX * dt;
        if (this.y < 0 || this.y > Game.height) this.active = false;
      }
      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // === ENEMIES ===
    class Enemy extends Entity {
      constructor(x, y, type) {
        const types = {
          basic: { w: 30, h: 30, color: '#f00', health: 1, points: 10, speed: 150 },
          fast: { w: 20, h: 20, color: '#f90', health: 1, points: 20, speed: 300 },
          tank: { w: 50, h: 50, color: '#900', health: 3, points: 50, speed: 80 },
          zigzag: { w: 30, h: 30, color: '#f0f', health: 2, points: 30, speed: 120 }
        };
        const stats = types[type];
        super(x, y, stats.w, stats.h, stats.color);
        this.health = stats.health;
        this.points = stats.points;
        this.velY = stats.speed;
        this.type = type;
        this.zigOffset = 0;
      }
      update(dt) {
        if (this.type === 'zigzag') {
          this.zigOffset += dt * 5;
          this.velX = Math.sin(this.zigOffset) * 100;
        }
        this.y += this.velY * dt;
        this.x += this.velX;
        if (this.y > Game.height + 50) this.active = false;
      }
      takeDamage() {
        this.health--;
        if (this.health <= 0) {
          this.die();
        }
      }
      die() {
        this.active = false;
        GameState.updateScore(this.points);
        for (let i = 0; i < 5; i++) {
          Particle.spawn(this.x, this.y, this.color);
        }
        if (Math.random() < 0.2) { // 20% chance for power-up
          PowerUp.spawnRandom(this.x, this.y);
        }
      }
    }

    // === BOSS ===
    class Boss extends Entity {
      constructor(x, y) {
        super(x, y, 120, 100, '#f0f');
        this.health = 50;
        this.maxHealth = 50;
        this.velY = 50;
        this.phase = 'descend';
        this.lastShot = 0;
        this.movePattern = 0;
      }
      update(dt) {
        this.lastShot -= dt;
        if (this.phase === 'descend') {
          this.y += this.velY;
          if (this.y >= 100) {
            this.phase = 'hover';
            this.lastShot = 0;
          }
        } else if (this.phase === 'hover') {
          this.movePattern += dt * 1.5;
          this.x = Game.width / 2 + Math.sin(this.movePattern) * 150;

          if (this.lastShot <= 0) {
            this.fire();
            this.lastShot = 0.5;
          }
          if (this.health <= 0) {
            this.die();
          }
        }
      }
      fire() {
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const vx = Math.sin(angle) * 150;
          const vy = Math.cos(angle) * 150;
          GameState.bullets.push(new Bullet(this.x, this.y + 50, vx, vy, '#f0f', 4, 1));
        }
      }
      die() {
        this.active = false;
        for (let i = 0; i < 50; i++) {
          Particle.spawn(this.x + (Math.random() - 0.5) * 100, this.y + (Math.random() - 0.5) * 50, '#f0f');
        }
        GameState.updateScore(500);
        GameState.levelUp();
      }
      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
        // Health bar
        const barW = this.width;
        const barH = 10;
        const hpRatio = this.health / this.maxHealth;
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - barW / 2, this.y - this.height / 2 - 20, barW, barH);
        ctx.fillStyle = 'lime';
        ctx.fillRect(this.x - barW / 2, this.y - this.height / 2 - 20, barW * hpRatio, barH);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(this.x - barW / 2, this.y - this.height / 2 - 20, barW, barH);
      }
    }

    // === POWER-UPS ===
    class PowerUp extends Entity {
      constructor(x, y, type) {
        const types = {
          shield: { color: '#0ff', text: 'SHIELD' },
          rapid: { color: '#ff0', text: 'RAPID' },
          laser: { color: '#0f0', text: 'LASER' },
          nuke: { color: '#f0f', text: 'NUKE' }
        };
        super(x, y, 20, 20, types[type].color);
        this.type = type;
        this.text = types[type].text;
        this.velY = 50;
      }
      update(dt) {
        this.y += this.velY;
        if (this.y > Game.height) this.active = false;
      }
      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.font = '10px monospace';
        ctx.fillText(this.text[0], this.x - 3, this.y + 3);
      }
      static spawnRandom(x, y) {
        const types = ['shield', 'rapid', 'laser', 'nuke'];
        const type = types[Math.floor(Math.random() * types.length)];
        GameState.powerUps.push(new PowerUp(x + (Math.random() - 0.5) * 40, y, type));
      }
    }

    // === PARTICLES ===
    class Particle extends Entity {
      constructor(x, y, color) {
        super(x, y, 2, 2, color);
        this.velX = (Math.random() - 0.5) * 200;
        this.velY = (Math.random() - 0.5) * 200;
        this.life = 1.0;
        this.decay = Math.random() * 0.5 + 0.5;
      }
      update(dt) {
        this.x += this.velX * dt;
        this.y += this.velY * dt;
        this.velY += 50 * dt;
        this.life -= this.decay * dt;
        if (this.life <= 0) this.active = false;
      }
      draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.globalAlpha = 1;
      }
      static spawn(x, y, color) {
        for (let i = 0; i < 8; i++) {
          GameState.particles.push(new Particle(x, y, color));
        }
      }
    }

    // === GAME UPDATE & RENDER ===
    Game.update = function (dt) {
      if (!GameState.player.active) return;

      // Update player
      GameState.player.update(dt);

      // Spawn enemies
      GameState.nextSpawn -= dt;
      if (GameState.nextSpawn <= 0 && !GameState.boss) {
        const types = ['basic', 'fast', 'tank', 'zigzag'];
        const type = types[Math.floor(Math.random() * (GameState.level > 2 ? 4 : 2))];
        const x = Math.random() * (Game.width - 100) + 50;
        GameState.enemies.push(new Enemy(x, -30, type));
        GameState.nextSpawn = Math.random() * (GameState.spawnRate * 0.5) + GameState.spawnRate * 0.5;
      }

      // Update bullets
      GameState.bullets = GameState.bullets.filter(b => b.active);
      GameState.bullets.forEach(b => b.update(dt));

      // Update enemies
      GameState.enemies = GameState.enemies.filter(e => e.active);
      GameState.enemies.forEach(e => e.update(dt));

      // Update particles
      GameState.particles = GameState.particles.filter(p => p.active);
      GameState.particles.forEach(p => p.update(dt));

      // Update power-ups
      GameState.powerUps = GameState.powerUps.filter(p => p.active);
      GameState.powerUps.forEach(p => p.update(dt));

      // Check bullet-enemy collisions
      GameState.bullets.forEach(bullet => {
        GameState.enemies.forEach(enemy => {
          if (bullet.active && enemy.active && bullet.isColliding(enemy)) {
            bullet.active = false;
            enemy.takeDamage();
          }
        });
        if (GameState.boss && bullet.active && bullet.isColliding(GameState.boss)) {
          bullet.active = false;
          GameState.boss.health--;
        }
      });

      // Check player-enemy or power-up collisions
      const player = GameState.player;
      GameState.enemies.forEach(enemy => {
        if (player.active && enemy.active && player.isColliding(enemy)) {
          enemy.active = false;
          player.takeDamage(10);
        }
      });
      GameState.powerUps.forEach(pu => {
        if (pu.active && player.isColliding(pu)) {
          pu.active = false;
          applyPowerUp(player, pu.type);
        }
      });

      // Boss update
      if (GameState.boss) {
        GameState.boss.update(dt);
        if (!GameState.boss.active) {
          GameState.boss = null;
          GameState.levelUp();
        }
      }

      // Level up check
      if (GameState.enemies.length === 0 && !GameState.boss && GameState.level > 1) {
        // Auto-proceed to next level after short delay
        setTimeout(() => {
          if (GameState.enemies.length === 0 && !GameState.boss) {
            GameState.levelUp();
            document.getElementById('level').textContent = GameState.level;
          }
        }, 3000);
      }
    };

    function applyPowerUp(player, type) {
      switch (type) {
        case 'shield':
          player.invincible = true;
          player.invincibleTime = 5.0;
          break;
        case 'rapid':
          player.rapidFire = true;
          player.rapidFireTime = 10.0;
          break;
        case 'laser':
          player.laserBeam = true;
          player.laserTime = 8.0;
          break;
        case 'nuke':
          GameState.enemies.forEach(e => e.takeDamage(999));
          GameState.updateScore(100 * GameState.enemies.filter(e => !e.active).length);
          Particle.spawn(Game.width / 2, Game.height / 2, '#f0f');
          break;
      }
    }

    Game.render = function () {
      const ctx = this.ctx;

      // Background
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, this.width, this.height);

      // Stars (simple parallax effect)
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 100; i++) {
        const x = (i * 987) % this.width;
        const y = (i * 123) % this.height;
        const size = (i % 3 === 0) ? 2 : 1;
        ctx.fillRect(x, y, size, size);
      }

      const player = GameState.player;
      if (player && player.active) player.draw(ctx);

      GameState.bullets.forEach(b => b.draw(ctx));
      GameState.enemies.forEach(e => e.draw(ctx));
      GameState.particles.forEach(p => p.draw(ctx));
      GameState.powerUps.forEach(p => p.draw(ctx));
      if (GameState.boss) GameState.boss.draw(ctx);

      // UI: Level Text
      if (GameState.enemies.length === 0 && !GameState.boss && GameState.level > 1) {
        ctx.fillStyle = 'rgba(0,255,0,0.8)';
        ctx.font = '40px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`LEVEL ${GameState.level}`, Game.width / 2, Game.height / 2);
        ctx.textAlign = 'left';
      }
    };

    // === INIT GAME ===
    window.addEventListener('load', () => {
      GameState.reset();
      Game.init();
    });
  </script>
</body>
</html>